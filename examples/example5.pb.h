// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: example5.proto

#ifndef PROTOBUF_example5_2eproto__INCLUDED
#define PROTOBUF_example5_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_example5_2eproto();
void protobuf_AssignDesc_example5_2eproto();
void protobuf_ShutdownFile_example5_2eproto();

class Simple;
class Invoice;
class Invoice_Line;
class Invoice_Company;
class Nested;
class Nested_Line;
class Nested_Line_Item;

// ===================================================================

class Simple : public ::google::protobuf::Message {
 public:
  Simple();
  virtual ~Simple();

  Simple(const Simple& from);

  inline Simple& operator=(const Simple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Simple& default_instance();

  void Swap(Simple* other);

  // implements Message ----------------------------------------------

  Simple* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Simple& from);
  void MergeFrom(const Simple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 age = 2;
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 2;
  inline ::google::protobuf::uint32 age() const;
  inline void set_age(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Simple)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_age();
  inline void clear_has_age();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 age_;
  friend void  protobuf_AddDesc_example5_2eproto();
  friend void protobuf_AssignDesc_example5_2eproto();
  friend void protobuf_ShutdownFile_example5_2eproto();

  void InitAsDefaultInstance();
  static Simple* default_instance_;
};
// -------------------------------------------------------------------

class Invoice_Line : public ::google::protobuf::Message {
 public:
  Invoice_Line();
  virtual ~Invoice_Line();

  Invoice_Line(const Invoice_Line& from);

  inline Invoice_Line& operator=(const Invoice_Line& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Invoice_Line& default_instance();

  void Swap(Invoice_Line* other);

  // implements Message ----------------------------------------------

  Invoice_Line* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Invoice_Line& from);
  void MergeFrom(const Invoice_Line& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string item_code = 1;
  inline bool has_item_code() const;
  inline void clear_item_code();
  static const int kItemCodeFieldNumber = 1;
  inline const ::std::string& item_code() const;
  inline void set_item_code(const ::std::string& value);
  inline void set_item_code(const char* value);
  inline void set_item_code(const char* value, size_t size);
  inline ::std::string* mutable_item_code();
  inline ::std::string* release_item_code();
  inline void set_allocated_item_code(::std::string* item_code);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline const ::std::string& amount() const;
  inline void set_amount(const ::std::string& value);
  inline void set_amount(const char* value);
  inline void set_amount(const char* value, size_t size);
  inline ::std::string* mutable_amount();
  inline ::std::string* release_amount();
  inline void set_allocated_amount(::std::string* amount);

  // @@protoc_insertion_point(class_scope:Invoice.Line)
 private:
  inline void set_has_item_code();
  inline void clear_has_item_code();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_amount();
  inline void clear_has_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* item_code_;
  ::std::string* description_;
  ::std::string* amount_;
  friend void  protobuf_AddDesc_example5_2eproto();
  friend void protobuf_AssignDesc_example5_2eproto();
  friend void protobuf_ShutdownFile_example5_2eproto();

  void InitAsDefaultInstance();
  static Invoice_Line* default_instance_;
};
// -------------------------------------------------------------------

class Invoice_Company : public ::google::protobuf::Message {
 public:
  Invoice_Company();
  virtual ~Invoice_Company();

  Invoice_Company(const Invoice_Company& from);

  inline Invoice_Company& operator=(const Invoice_Company& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Invoice_Company& default_instance();

  void Swap(Invoice_Company* other);

  // implements Message ----------------------------------------------

  Invoice_Company* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Invoice_Company& from);
  void MergeFrom(const Invoice_Company& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string street = 2;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 2;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string city = 3;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 3;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string state = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional string zip = 5;
  inline bool has_zip() const;
  inline void clear_zip();
  static const int kZipFieldNumber = 5;
  inline const ::std::string& zip() const;
  inline void set_zip(const ::std::string& value);
  inline void set_zip(const char* value);
  inline void set_zip(const char* value, size_t size);
  inline ::std::string* mutable_zip();
  inline ::std::string* release_zip();
  inline void set_allocated_zip(::std::string* zip);

  // @@protoc_insertion_point(class_scope:Invoice.Company)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_zip();
  inline void clear_has_zip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* street_;
  ::std::string* city_;
  ::std::string* state_;
  ::std::string* zip_;
  friend void  protobuf_AddDesc_example5_2eproto();
  friend void protobuf_AssignDesc_example5_2eproto();
  friend void protobuf_ShutdownFile_example5_2eproto();

  void InitAsDefaultInstance();
  static Invoice_Company* default_instance_;
};
// -------------------------------------------------------------------

class Invoice : public ::google::protobuf::Message {
 public:
  Invoice();
  virtual ~Invoice();

  Invoice(const Invoice& from);

  inline Invoice& operator=(const Invoice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Invoice& default_instance();

  void Swap(Invoice* other);

  // implements Message ----------------------------------------------

  Invoice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Invoice& from);
  void MergeFrom(const Invoice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Invoice_Line Line;
  typedef Invoice_Company Company;

  // accessors -------------------------------------------------------

  // repeated .Invoice.Line lines = 1;
  inline int lines_size() const;
  inline void clear_lines();
  static const int kLinesFieldNumber = 1;
  inline const ::Invoice_Line& lines(int index) const;
  inline ::Invoice_Line* mutable_lines(int index);
  inline ::Invoice_Line* add_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::Invoice_Line >&
      lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::Invoice_Line >*
      mutable_lines();

  // optional int64 invoice_number = 2;
  inline bool has_invoice_number() const;
  inline void clear_invoice_number();
  static const int kInvoiceNumberFieldNumber = 2;
  inline ::google::protobuf::int64 invoice_number() const;
  inline void set_invoice_number(::google::protobuf::int64 value);

  // optional .Invoice.Company company = 3;
  inline bool has_company() const;
  inline void clear_company();
  static const int kCompanyFieldNumber = 3;
  inline const ::Invoice_Company& company() const;
  inline ::Invoice_Company* mutable_company();
  inline ::Invoice_Company* release_company();
  inline void set_allocated_company(::Invoice_Company* company);

  // @@protoc_insertion_point(class_scope:Invoice)
 private:
  inline void set_has_invoice_number();
  inline void clear_has_invoice_number();
  inline void set_has_company();
  inline void clear_has_company();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Invoice_Line > lines_;
  ::google::protobuf::int64 invoice_number_;
  ::Invoice_Company* company_;
  friend void  protobuf_AddDesc_example5_2eproto();
  friend void protobuf_AssignDesc_example5_2eproto();
  friend void protobuf_ShutdownFile_example5_2eproto();

  void InitAsDefaultInstance();
  static Invoice* default_instance_;
};
// -------------------------------------------------------------------

class Nested_Line_Item : public ::google::protobuf::Message {
 public:
  Nested_Line_Item();
  virtual ~Nested_Line_Item();

  Nested_Line_Item(const Nested_Line_Item& from);

  inline Nested_Line_Item& operator=(const Nested_Line_Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Nested_Line_Item& default_instance();

  void Swap(Nested_Line_Item* other);

  // implements Message ----------------------------------------------

  Nested_Line_Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Nested_Line_Item& from);
  void MergeFrom(const Nested_Line_Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Nested.Line.Item)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_example5_2eproto();
  friend void protobuf_AssignDesc_example5_2eproto();
  friend void protobuf_ShutdownFile_example5_2eproto();

  void InitAsDefaultInstance();
  static Nested_Line_Item* default_instance_;
};
// -------------------------------------------------------------------

class Nested_Line : public ::google::protobuf::Message {
 public:
  Nested_Line();
  virtual ~Nested_Line();

  Nested_Line(const Nested_Line& from);

  inline Nested_Line& operator=(const Nested_Line& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Nested_Line& default_instance();

  void Swap(Nested_Line* other);

  // implements Message ----------------------------------------------

  Nested_Line* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Nested_Line& from);
  void MergeFrom(const Nested_Line& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Nested_Line_Item Item;

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // repeated .Nested.Line.Item items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::Nested_Line_Item& items(int index) const;
  inline ::Nested_Line_Item* mutable_items(int index);
  inline ::Nested_Line_Item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Nested_Line_Item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Nested_Line_Item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Nested.Line)
 private:
  inline void set_has_title();
  inline void clear_has_title();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::google::protobuf::RepeatedPtrField< ::Nested_Line_Item > items_;
  friend void  protobuf_AddDesc_example5_2eproto();
  friend void protobuf_AssignDesc_example5_2eproto();
  friend void protobuf_ShutdownFile_example5_2eproto();

  void InitAsDefaultInstance();
  static Nested_Line* default_instance_;
};
// -------------------------------------------------------------------

class Nested : public ::google::protobuf::Message {
 public:
  Nested();
  virtual ~Nested();

  Nested(const Nested& from);

  inline Nested& operator=(const Nested& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Nested& default_instance();

  void Swap(Nested* other);

  // implements Message ----------------------------------------------

  Nested* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Nested& from);
  void MergeFrom(const Nested& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Nested_Line Line;

  // accessors -------------------------------------------------------

  // repeated .Nested.Line lines = 1;
  inline int lines_size() const;
  inline void clear_lines();
  static const int kLinesFieldNumber = 1;
  inline const ::Nested_Line& lines(int index) const;
  inline ::Nested_Line* mutable_lines(int index);
  inline ::Nested_Line* add_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::Nested_Line >&
      lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::Nested_Line >*
      mutable_lines();

  // @@protoc_insertion_point(class_scope:Nested)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Nested_Line > lines_;
  friend void  protobuf_AddDesc_example5_2eproto();
  friend void protobuf_AssignDesc_example5_2eproto();
  friend void protobuf_ShutdownFile_example5_2eproto();

  void InitAsDefaultInstance();
  static Nested* default_instance_;
};
// ===================================================================


// ===================================================================

// Simple

// optional string name = 1;
inline bool Simple::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Simple::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Simple::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Simple::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Simple::name() const {
  // @@protoc_insertion_point(field_get:Simple.name)
  return *name_;
}
inline void Simple::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Simple.name)
}
inline void Simple::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Simple.name)
}
inline void Simple::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Simple.name)
}
inline ::std::string* Simple::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Simple.name)
  return name_;
}
inline ::std::string* Simple::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Simple::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Simple.name)
}

// optional uint32 age = 2;
inline bool Simple::has_age() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Simple::set_has_age() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Simple::clear_has_age() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Simple::clear_age() {
  age_ = 0u;
  clear_has_age();
}
inline ::google::protobuf::uint32 Simple::age() const {
  // @@protoc_insertion_point(field_get:Simple.age)
  return age_;
}
inline void Simple::set_age(::google::protobuf::uint32 value) {
  set_has_age();
  age_ = value;
  // @@protoc_insertion_point(field_set:Simple.age)
}

// -------------------------------------------------------------------

// Invoice_Line

// optional string item_code = 1;
inline bool Invoice_Line::has_item_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Invoice_Line::set_has_item_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Invoice_Line::clear_has_item_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Invoice_Line::clear_item_code() {
  if (item_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    item_code_->clear();
  }
  clear_has_item_code();
}
inline const ::std::string& Invoice_Line::item_code() const {
  // @@protoc_insertion_point(field_get:Invoice.Line.item_code)
  return *item_code_;
}
inline void Invoice_Line::set_item_code(const ::std::string& value) {
  set_has_item_code();
  if (item_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    item_code_ = new ::std::string;
  }
  item_code_->assign(value);
  // @@protoc_insertion_point(field_set:Invoice.Line.item_code)
}
inline void Invoice_Line::set_item_code(const char* value) {
  set_has_item_code();
  if (item_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    item_code_ = new ::std::string;
  }
  item_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:Invoice.Line.item_code)
}
inline void Invoice_Line::set_item_code(const char* value, size_t size) {
  set_has_item_code();
  if (item_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    item_code_ = new ::std::string;
  }
  item_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Invoice.Line.item_code)
}
inline ::std::string* Invoice_Line::mutable_item_code() {
  set_has_item_code();
  if (item_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    item_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Invoice.Line.item_code)
  return item_code_;
}
inline ::std::string* Invoice_Line::release_item_code() {
  clear_has_item_code();
  if (item_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = item_code_;
    item_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoice_Line::set_allocated_item_code(::std::string* item_code) {
  if (item_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete item_code_;
  }
  if (item_code) {
    set_has_item_code();
    item_code_ = item_code;
  } else {
    clear_has_item_code();
    item_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Invoice.Line.item_code)
}

// optional string description = 2;
inline bool Invoice_Line::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Invoice_Line::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Invoice_Line::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Invoice_Line::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Invoice_Line::description() const {
  // @@protoc_insertion_point(field_get:Invoice.Line.description)
  return *description_;
}
inline void Invoice_Line::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:Invoice.Line.description)
}
inline void Invoice_Line::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:Invoice.Line.description)
}
inline void Invoice_Line::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Invoice.Line.description)
}
inline ::std::string* Invoice_Line::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Invoice.Line.description)
  return description_;
}
inline ::std::string* Invoice_Line::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoice_Line::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Invoice.Line.description)
}

// optional string amount = 3;
inline bool Invoice_Line::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Invoice_Line::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Invoice_Line::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Invoice_Line::clear_amount() {
  if (amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_->clear();
  }
  clear_has_amount();
}
inline const ::std::string& Invoice_Line::amount() const {
  // @@protoc_insertion_point(field_get:Invoice.Line.amount)
  return *amount_;
}
inline void Invoice_Line::set_amount(const ::std::string& value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
  // @@protoc_insertion_point(field_set:Invoice.Line.amount)
}
inline void Invoice_Line::set_amount(const char* value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
  // @@protoc_insertion_point(field_set_char:Invoice.Line.amount)
}
inline void Invoice_Line::set_amount(const char* value, size_t size) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  amount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Invoice.Line.amount)
}
inline ::std::string* Invoice_Line::mutable_amount() {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Invoice.Line.amount)
  return amount_;
}
inline ::std::string* Invoice_Line::release_amount() {
  clear_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = amount_;
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoice_Line::set_allocated_amount(::std::string* amount) {
  if (amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete amount_;
  }
  if (amount) {
    set_has_amount();
    amount_ = amount;
  } else {
    clear_has_amount();
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Invoice.Line.amount)
}

// -------------------------------------------------------------------

// Invoice_Company

// optional string name = 1;
inline bool Invoice_Company::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Invoice_Company::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Invoice_Company::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Invoice_Company::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Invoice_Company::name() const {
  // @@protoc_insertion_point(field_get:Invoice.Company.name)
  return *name_;
}
inline void Invoice_Company::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Invoice.Company.name)
}
inline void Invoice_Company::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Invoice.Company.name)
}
inline void Invoice_Company::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Invoice.Company.name)
}
inline ::std::string* Invoice_Company::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Invoice.Company.name)
  return name_;
}
inline ::std::string* Invoice_Company::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoice_Company::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Invoice.Company.name)
}

// optional string street = 2;
inline bool Invoice_Company::has_street() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Invoice_Company::set_has_street() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Invoice_Company::clear_has_street() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Invoice_Company::clear_street() {
  if (street_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& Invoice_Company::street() const {
  // @@protoc_insertion_point(field_get:Invoice.Company.street)
  return *street_;
}
inline void Invoice_Company::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  street_->assign(value);
  // @@protoc_insertion_point(field_set:Invoice.Company.street)
}
inline void Invoice_Company::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  street_->assign(value);
  // @@protoc_insertion_point(field_set_char:Invoice.Company.street)
}
inline void Invoice_Company::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Invoice.Company.street)
}
inline ::std::string* Invoice_Company::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Invoice.Company.street)
  return street_;
}
inline ::std::string* Invoice_Company::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoice_Company::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Invoice.Company.street)
}

// optional string city = 3;
inline bool Invoice_Company::has_city() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Invoice_Company::set_has_city() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Invoice_Company::clear_has_city() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Invoice_Company::clear_city() {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& Invoice_Company::city() const {
  // @@protoc_insertion_point(field_get:Invoice.Company.city)
  return *city_;
}
inline void Invoice_Company::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set:Invoice.Company.city)
}
inline void Invoice_Company::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set_char:Invoice.Company.city)
}
inline void Invoice_Company::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Invoice.Company.city)
}
inline ::std::string* Invoice_Company::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Invoice.Company.city)
  return city_;
}
inline ::std::string* Invoice_Company::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoice_Company::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Invoice.Company.city)
}

// optional string state = 4;
inline bool Invoice_Company::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Invoice_Company::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Invoice_Company::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Invoice_Company::clear_state() {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& Invoice_Company::state() const {
  // @@protoc_insertion_point(field_get:Invoice.Company.state)
  return *state_;
}
inline void Invoice_Company::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set:Invoice.Company.state)
}
inline void Invoice_Company::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set_char:Invoice.Company.state)
}
inline void Invoice_Company::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Invoice.Company.state)
}
inline ::std::string* Invoice_Company::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Invoice.Company.state)
  return state_;
}
inline ::std::string* Invoice_Company::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoice_Company::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Invoice.Company.state)
}

// optional string zip = 5;
inline bool Invoice_Company::has_zip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Invoice_Company::set_has_zip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Invoice_Company::clear_has_zip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Invoice_Company::clear_zip() {
  if (zip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_->clear();
  }
  clear_has_zip();
}
inline const ::std::string& Invoice_Company::zip() const {
  // @@protoc_insertion_point(field_get:Invoice.Company.zip)
  return *zip_;
}
inline void Invoice_Company::set_zip(const ::std::string& value) {
  set_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_ = new ::std::string;
  }
  zip_->assign(value);
  // @@protoc_insertion_point(field_set:Invoice.Company.zip)
}
inline void Invoice_Company::set_zip(const char* value) {
  set_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_ = new ::std::string;
  }
  zip_->assign(value);
  // @@protoc_insertion_point(field_set_char:Invoice.Company.zip)
}
inline void Invoice_Company::set_zip(const char* value, size_t size) {
  set_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_ = new ::std::string;
  }
  zip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Invoice.Company.zip)
}
inline ::std::string* Invoice_Company::mutable_zip() {
  set_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Invoice.Company.zip)
  return zip_;
}
inline ::std::string* Invoice_Company::release_zip() {
  clear_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = zip_;
    zip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoice_Company::set_allocated_zip(::std::string* zip) {
  if (zip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete zip_;
  }
  if (zip) {
    set_has_zip();
    zip_ = zip;
  } else {
    clear_has_zip();
    zip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Invoice.Company.zip)
}

// -------------------------------------------------------------------

// Invoice

// repeated .Invoice.Line lines = 1;
inline int Invoice::lines_size() const {
  return lines_.size();
}
inline void Invoice::clear_lines() {
  lines_.Clear();
}
inline const ::Invoice_Line& Invoice::lines(int index) const {
  // @@protoc_insertion_point(field_get:Invoice.lines)
  return lines_.Get(index);
}
inline ::Invoice_Line* Invoice::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:Invoice.lines)
  return lines_.Mutable(index);
}
inline ::Invoice_Line* Invoice::add_lines() {
  // @@protoc_insertion_point(field_add:Invoice.lines)
  return lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Invoice_Line >&
Invoice::lines() const {
  // @@protoc_insertion_point(field_list:Invoice.lines)
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::Invoice_Line >*
Invoice::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:Invoice.lines)
  return &lines_;
}

// optional int64 invoice_number = 2;
inline bool Invoice::has_invoice_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Invoice::set_has_invoice_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Invoice::clear_has_invoice_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Invoice::clear_invoice_number() {
  invoice_number_ = GOOGLE_LONGLONG(0);
  clear_has_invoice_number();
}
inline ::google::protobuf::int64 Invoice::invoice_number() const {
  // @@protoc_insertion_point(field_get:Invoice.invoice_number)
  return invoice_number_;
}
inline void Invoice::set_invoice_number(::google::protobuf::int64 value) {
  set_has_invoice_number();
  invoice_number_ = value;
  // @@protoc_insertion_point(field_set:Invoice.invoice_number)
}

// optional .Invoice.Company company = 3;
inline bool Invoice::has_company() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Invoice::set_has_company() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Invoice::clear_has_company() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Invoice::clear_company() {
  if (company_ != NULL) company_->::Invoice_Company::Clear();
  clear_has_company();
}
inline const ::Invoice_Company& Invoice::company() const {
  // @@protoc_insertion_point(field_get:Invoice.company)
  return company_ != NULL ? *company_ : *default_instance_->company_;
}
inline ::Invoice_Company* Invoice::mutable_company() {
  set_has_company();
  if (company_ == NULL) company_ = new ::Invoice_Company;
  // @@protoc_insertion_point(field_mutable:Invoice.company)
  return company_;
}
inline ::Invoice_Company* Invoice::release_company() {
  clear_has_company();
  ::Invoice_Company* temp = company_;
  company_ = NULL;
  return temp;
}
inline void Invoice::set_allocated_company(::Invoice_Company* company) {
  delete company_;
  company_ = company;
  if (company) {
    set_has_company();
  } else {
    clear_has_company();
  }
  // @@protoc_insertion_point(field_set_allocated:Invoice.company)
}

// -------------------------------------------------------------------

// Nested_Line_Item

// optional string name = 1;
inline bool Nested_Line_Item::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Nested_Line_Item::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Nested_Line_Item::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Nested_Line_Item::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Nested_Line_Item::name() const {
  // @@protoc_insertion_point(field_get:Nested.Line.Item.name)
  return *name_;
}
inline void Nested_Line_Item::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Nested.Line.Item.name)
}
inline void Nested_Line_Item::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Nested.Line.Item.name)
}
inline void Nested_Line_Item::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Nested.Line.Item.name)
}
inline ::std::string* Nested_Line_Item::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Nested.Line.Item.name)
  return name_;
}
inline ::std::string* Nested_Line_Item::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Nested_Line_Item::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Nested.Line.Item.name)
}

// optional string value = 2;
inline bool Nested_Line_Item::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Nested_Line_Item::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Nested_Line_Item::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Nested_Line_Item::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Nested_Line_Item::value() const {
  // @@protoc_insertion_point(field_get:Nested.Line.Item.value)
  return *value_;
}
inline void Nested_Line_Item::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:Nested.Line.Item.value)
}
inline void Nested_Line_Item::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:Nested.Line.Item.value)
}
inline void Nested_Line_Item::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Nested.Line.Item.value)
}
inline ::std::string* Nested_Line_Item::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Nested.Line.Item.value)
  return value_;
}
inline ::std::string* Nested_Line_Item::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Nested_Line_Item::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Nested.Line.Item.value)
}

// -------------------------------------------------------------------

// Nested_Line

// optional string title = 1;
inline bool Nested_Line::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Nested_Line::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Nested_Line::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Nested_Line::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Nested_Line::title() const {
  // @@protoc_insertion_point(field_get:Nested.Line.title)
  return *title_;
}
inline void Nested_Line::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:Nested.Line.title)
}
inline void Nested_Line::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:Nested.Line.title)
}
inline void Nested_Line::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Nested.Line.title)
}
inline ::std::string* Nested_Line::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Nested.Line.title)
  return title_;
}
inline ::std::string* Nested_Line::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Nested_Line::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Nested.Line.title)
}

// repeated .Nested.Line.Item items = 2;
inline int Nested_Line::items_size() const {
  return items_.size();
}
inline void Nested_Line::clear_items() {
  items_.Clear();
}
inline const ::Nested_Line_Item& Nested_Line::items(int index) const {
  // @@protoc_insertion_point(field_get:Nested.Line.items)
  return items_.Get(index);
}
inline ::Nested_Line_Item* Nested_Line::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Nested.Line.items)
  return items_.Mutable(index);
}
inline ::Nested_Line_Item* Nested_Line::add_items() {
  // @@protoc_insertion_point(field_add:Nested.Line.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Nested_Line_Item >&
Nested_Line::items() const {
  // @@protoc_insertion_point(field_list:Nested.Line.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Nested_Line_Item >*
Nested_Line::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Nested.Line.items)
  return &items_;
}

// -------------------------------------------------------------------

// Nested

// repeated .Nested.Line lines = 1;
inline int Nested::lines_size() const {
  return lines_.size();
}
inline void Nested::clear_lines() {
  lines_.Clear();
}
inline const ::Nested_Line& Nested::lines(int index) const {
  // @@protoc_insertion_point(field_get:Nested.lines)
  return lines_.Get(index);
}
inline ::Nested_Line* Nested::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:Nested.lines)
  return lines_.Mutable(index);
}
inline ::Nested_Line* Nested::add_lines() {
  // @@protoc_insertion_point(field_add:Nested.lines)
  return lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Nested_Line >&
Nested::lines() const {
  // @@protoc_insertion_point(field_list:Nested.lines)
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::Nested_Line >*
Nested::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:Nested.lines)
  return &lines_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_example5_2eproto__INCLUDED
